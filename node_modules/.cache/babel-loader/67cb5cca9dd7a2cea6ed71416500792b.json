{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getBreaksNeededForEmptyLineAfter = exports.getBreaksNeededForEmptyLineBefore = exports.selectWord = exports.getSurroundingWord = void 0;\n\nfunction getSurroundingWord(text, position) {\n  if (!text) throw Error(\"Argument 'text' should be truthy\");\n\n  var isWordDelimiter = function (c) {\n    return c === \" \" || c.charCodeAt(0) === 10;\n  }; // leftIndex is initialized to 0 because if selection is 0, it won't even enter the iteration\n\n\n  var start = 0; // rightIndex is initialized to text.length because if selection is equal to text.length it won't even enter the interation\n\n  var end = text.length; // iterate to the left\n\n  for (var i = position; i - 1 > -1; i--) {\n    if (isWordDelimiter(text[i - 1])) {\n      start = i;\n      break;\n    }\n  } // iterate to the right\n\n\n  for (var i = position; i < text.length; i++) {\n    if (isWordDelimiter(text[i])) {\n      end = i;\n      break;\n    }\n  }\n\n  return {\n    start: start,\n    end: end\n  };\n}\n\nexports.getSurroundingWord = getSurroundingWord;\n/**\n * If the cursor is inside a word and (selection.start === selection.end)\n * returns a new Selection where the whole word is selected\n * @param text\n * @param selection\n */\n\nfunction selectWord(_a) {\n  var text = _a.text,\n      selection = _a.selection;\n\n  if (text && text.length && selection.start === selection.end) {\n    // the user is pointing to a word\n    return getSurroundingWord(text, selection.start);\n  }\n\n  return selection;\n}\n\nexports.selectWord = selectWord;\n/**\n *  Gets the number of line-breaks that would have to be inserted before the given 'startPosition'\n *  to make sure there's an empty line between 'startPosition' and the previous text\n */\n\nfunction getBreaksNeededForEmptyLineBefore(text, startPosition) {\n  if (text === void 0) {\n    text = \"\";\n  }\n\n  if (startPosition === 0) return 0; // rules:\n  // - If we're in the first line, no breaks are needed\n  // - Otherwise there must be 2 breaks before the previous character. Depending on how many breaks exist already, we\n  //      may need to insert 0, 1 or 2 breaks\n\n  var neededBreaks = 2;\n  var isInFirstLine = true;\n\n  for (var i = startPosition - 1; i >= 0 && neededBreaks >= 0; i--) {\n    switch (text.charCodeAt(i)) {\n      case 32:\n        // blank space\n        continue;\n\n      case 10:\n        // line break\n        neededBreaks--;\n        isInFirstLine = false;\n        break;\n\n      default:\n        return neededBreaks;\n    }\n  }\n\n  return isInFirstLine ? 0 : neededBreaks;\n}\n\nexports.getBreaksNeededForEmptyLineBefore = getBreaksNeededForEmptyLineBefore;\n/**\n *  Gets the number of line-breaks that would have to be inserted after the given 'startPosition'\n *  to make sure there's an empty line between 'startPosition' and the next text\n */\n\nfunction getBreaksNeededForEmptyLineAfter(text, startPosition) {\n  if (text === void 0) {\n    text = \"\";\n  }\n\n  if (startPosition === text.length - 1) return 0; // rules:\n  // - If we're in the first line, no breaks are needed\n  // - Otherwise there must be 2 breaks before the previous character. Depending on how many breaks exist already, we\n  //      may need to insert 0, 1 or 2 breaks\n\n  var neededBreaks = 2;\n  var isInLastLine = true;\n\n  for (var i = startPosition; i < text.length && neededBreaks >= 0; i++) {\n    switch (text.charCodeAt(i)) {\n      case 32:\n        continue;\n\n      case 10:\n        {\n          neededBreaks--;\n          isInLastLine = false;\n          break;\n        }\n\n      default:\n        return neededBreaks;\n    }\n  }\n\n  return isInLastLine ? 0 : neededBreaks;\n}\n\nexports.getBreaksNeededForEmptyLineAfter = getBreaksNeededForEmptyLineAfter;","map":{"version":3,"sources":["/home/faha/local-repo/journey-to-react/2.notes-app/node_modules/react-mde/lib/js/util/MarkdownUtil.js"],"names":["Object","defineProperty","exports","value","getBreaksNeededForEmptyLineAfter","getBreaksNeededForEmptyLineBefore","selectWord","getSurroundingWord","text","position","Error","isWordDelimiter","c","charCodeAt","start","end","length","i","_a","selection","startPosition","neededBreaks","isInFirstLine","isInLastLine"],"mappings":"AAAA;;AACAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;AACAD,OAAO,CAACE,gCAAR,GAA2CF,OAAO,CAACG,iCAAR,GAA4CH,OAAO,CAACI,UAAR,GAAqBJ,OAAO,CAACK,kBAAR,GAA6B,KAAK,CAA9I;;AACA,SAASA,kBAAT,CAA4BC,IAA5B,EAAkCC,QAAlC,EAA4C;AACxC,MAAI,CAACD,IAAL,EACI,MAAME,KAAK,CAAC,kCAAD,CAAX;;AACJ,MAAIC,eAAe,GAAG,UAAUC,CAAV,EAAa;AAAE,WAAOA,CAAC,KAAK,GAAN,IAAaA,CAAC,CAACC,UAAF,CAAa,CAAb,MAAoB,EAAxC;AAA6C,GAAlF,CAHwC,CAIxC;;;AACA,MAAIC,KAAK,GAAG,CAAZ,CALwC,CAMxC;;AACA,MAAIC,GAAG,GAAGP,IAAI,CAACQ,MAAf,CAPwC,CAQxC;;AACA,OAAK,IAAIC,CAAC,GAAGR,QAAb,EAAuBQ,CAAC,GAAG,CAAJ,GAAQ,CAAC,CAAhC,EAAmCA,CAAC,EAApC,EAAwC;AACpC,QAAIN,eAAe,CAACH,IAAI,CAACS,CAAC,GAAG,CAAL,CAAL,CAAnB,EAAkC;AAC9BH,MAAAA,KAAK,GAAGG,CAAR;AACA;AACH;AACJ,GAduC,CAexC;;;AACA,OAAK,IAAIA,CAAC,GAAGR,QAAb,EAAuBQ,CAAC,GAAGT,IAAI,CAACQ,MAAhC,EAAwCC,CAAC,EAAzC,EAA6C;AACzC,QAAIN,eAAe,CAACH,IAAI,CAACS,CAAD,CAAL,CAAnB,EAA8B;AAC1BF,MAAAA,GAAG,GAAGE,CAAN;AACA;AACH;AACJ;;AACD,SAAO;AAAEH,IAAAA,KAAK,EAAEA,KAAT;AAAgBC,IAAAA,GAAG,EAAEA;AAArB,GAAP;AACH;;AACDb,OAAO,CAACK,kBAAR,GAA6BA,kBAA7B;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASD,UAAT,CAAoBY,EAApB,EAAwB;AACpB,MAAIV,IAAI,GAAGU,EAAE,CAACV,IAAd;AAAA,MAAoBW,SAAS,GAAGD,EAAE,CAACC,SAAnC;;AACA,MAAIX,IAAI,IAAIA,IAAI,CAACQ,MAAb,IAAuBG,SAAS,CAACL,KAAV,KAAoBK,SAAS,CAACJ,GAAzD,EAA8D;AAC1D;AACA,WAAOR,kBAAkB,CAACC,IAAD,EAAOW,SAAS,CAACL,KAAjB,CAAzB;AACH;;AACD,SAAOK,SAAP;AACH;;AACDjB,OAAO,CAACI,UAAR,GAAqBA,UAArB;AACA;AACA;AACA;AACA;;AACA,SAASD,iCAAT,CAA2CG,IAA3C,EAAiDY,aAAjD,EAAgE;AAC5D,MAAIZ,IAAI,KAAK,KAAK,CAAlB,EAAqB;AAAEA,IAAAA,IAAI,GAAG,EAAP;AAAY;;AACnC,MAAIY,aAAa,KAAK,CAAtB,EACI,OAAO,CAAP,CAHwD,CAI5D;AACA;AACA;AACA;;AACA,MAAIC,YAAY,GAAG,CAAnB;AACA,MAAIC,aAAa,GAAG,IAApB;;AACA,OAAK,IAAIL,CAAC,GAAGG,aAAa,GAAG,CAA7B,EAAgCH,CAAC,IAAI,CAAL,IAAUI,YAAY,IAAI,CAA1D,EAA6DJ,CAAC,EAA9D,EAAkE;AAC9D,YAAQT,IAAI,CAACK,UAAL,CAAgBI,CAAhB,CAAR;AACI,WAAK,EAAL;AAAS;AACL;;AACJ,WAAK,EAAL;AAAS;AACLI,QAAAA,YAAY;AACZC,QAAAA,aAAa,GAAG,KAAhB;AACA;;AACJ;AACI,eAAOD,YAAP;AARR;AAUH;;AACD,SAAOC,aAAa,GAAG,CAAH,GAAOD,YAA3B;AACH;;AACDnB,OAAO,CAACG,iCAAR,GAA4CA,iCAA5C;AACA;AACA;AACA;AACA;;AACA,SAASD,gCAAT,CAA0CI,IAA1C,EAAgDY,aAAhD,EAA+D;AAC3D,MAAIZ,IAAI,KAAK,KAAK,CAAlB,EAAqB;AAAEA,IAAAA,IAAI,GAAG,EAAP;AAAY;;AACnC,MAAIY,aAAa,KAAKZ,IAAI,CAACQ,MAAL,GAAc,CAApC,EACI,OAAO,CAAP,CAHuD,CAI3D;AACA;AACA;AACA;;AACA,MAAIK,YAAY,GAAG,CAAnB;AACA,MAAIE,YAAY,GAAG,IAAnB;;AACA,OAAK,IAAIN,CAAC,GAAGG,aAAb,EAA4BH,CAAC,GAAGT,IAAI,CAACQ,MAAT,IAAmBK,YAAY,IAAI,CAA/D,EAAkEJ,CAAC,EAAnE,EAAuE;AACnE,YAAQT,IAAI,CAACK,UAAL,CAAgBI,CAAhB,CAAR;AACI,WAAK,EAAL;AACI;;AACJ,WAAK,EAAL;AAAS;AACLI,UAAAA,YAAY;AACZE,UAAAA,YAAY,GAAG,KAAf;AACA;AACH;;AACD;AACI,eAAOF,YAAP;AATR;AAWH;;AACD,SAAOE,YAAY,GAAG,CAAH,GAAOF,YAA1B;AACH;;AACDnB,OAAO,CAACE,gCAAR,GAA2CA,gCAA3C","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getBreaksNeededForEmptyLineAfter = exports.getBreaksNeededForEmptyLineBefore = exports.selectWord = exports.getSurroundingWord = void 0;\nfunction getSurroundingWord(text, position) {\n    if (!text)\n        throw Error(\"Argument 'text' should be truthy\");\n    var isWordDelimiter = function (c) { return c === \" \" || c.charCodeAt(0) === 10; };\n    // leftIndex is initialized to 0 because if selection is 0, it won't even enter the iteration\n    var start = 0;\n    // rightIndex is initialized to text.length because if selection is equal to text.length it won't even enter the interation\n    var end = text.length;\n    // iterate to the left\n    for (var i = position; i - 1 > -1; i--) {\n        if (isWordDelimiter(text[i - 1])) {\n            start = i;\n            break;\n        }\n    }\n    // iterate to the right\n    for (var i = position; i < text.length; i++) {\n        if (isWordDelimiter(text[i])) {\n            end = i;\n            break;\n        }\n    }\n    return { start: start, end: end };\n}\nexports.getSurroundingWord = getSurroundingWord;\n/**\n * If the cursor is inside a word and (selection.start === selection.end)\n * returns a new Selection where the whole word is selected\n * @param text\n * @param selection\n */\nfunction selectWord(_a) {\n    var text = _a.text, selection = _a.selection;\n    if (text && text.length && selection.start === selection.end) {\n        // the user is pointing to a word\n        return getSurroundingWord(text, selection.start);\n    }\n    return selection;\n}\nexports.selectWord = selectWord;\n/**\n *  Gets the number of line-breaks that would have to be inserted before the given 'startPosition'\n *  to make sure there's an empty line between 'startPosition' and the previous text\n */\nfunction getBreaksNeededForEmptyLineBefore(text, startPosition) {\n    if (text === void 0) { text = \"\"; }\n    if (startPosition === 0)\n        return 0;\n    // rules:\n    // - If we're in the first line, no breaks are needed\n    // - Otherwise there must be 2 breaks before the previous character. Depending on how many breaks exist already, we\n    //      may need to insert 0, 1 or 2 breaks\n    var neededBreaks = 2;\n    var isInFirstLine = true;\n    for (var i = startPosition - 1; i >= 0 && neededBreaks >= 0; i--) {\n        switch (text.charCodeAt(i)) {\n            case 32: // blank space\n                continue;\n            case 10: // line break\n                neededBreaks--;\n                isInFirstLine = false;\n                break;\n            default:\n                return neededBreaks;\n        }\n    }\n    return isInFirstLine ? 0 : neededBreaks;\n}\nexports.getBreaksNeededForEmptyLineBefore = getBreaksNeededForEmptyLineBefore;\n/**\n *  Gets the number of line-breaks that would have to be inserted after the given 'startPosition'\n *  to make sure there's an empty line between 'startPosition' and the next text\n */\nfunction getBreaksNeededForEmptyLineAfter(text, startPosition) {\n    if (text === void 0) { text = \"\"; }\n    if (startPosition === text.length - 1)\n        return 0;\n    // rules:\n    // - If we're in the first line, no breaks are needed\n    // - Otherwise there must be 2 breaks before the previous character. Depending on how many breaks exist already, we\n    //      may need to insert 0, 1 or 2 breaks\n    var neededBreaks = 2;\n    var isInLastLine = true;\n    for (var i = startPosition; i < text.length && neededBreaks >= 0; i++) {\n        switch (text.charCodeAt(i)) {\n            case 32:\n                continue;\n            case 10: {\n                neededBreaks--;\n                isInLastLine = false;\n                break;\n            }\n            default:\n                return neededBreaks;\n        }\n    }\n    return isInLastLine ? 0 : neededBreaks;\n}\nexports.getBreaksNeededForEmptyLineAfter = getBreaksNeededForEmptyLineAfter;\n"]},"metadata":{},"sourceType":"script"}