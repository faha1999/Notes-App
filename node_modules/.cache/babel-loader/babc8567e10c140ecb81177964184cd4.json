{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.checkedListCommand = exports.orderedListCommand = exports.unorderedListCommand = exports.makeList = exports.insertBeforeEachLine = void 0;\n\nvar MarkdownUtil_1 = require(\"../../util/MarkdownUtil\");\n/**\n * Inserts insertionString before each line\n */\n\n\nfunction insertBeforeEachLine(selectedText, insertBefore) {\n  var lines = selectedText.split(/\\n/);\n  var insertionLength = 0;\n  var modifiedText = lines.map(function (item, index) {\n    if (typeof insertBefore === \"string\") {\n      insertionLength += insertBefore.length;\n      return insertBefore + item;\n    } else if (typeof insertBefore === \"function\") {\n      var insertionResult = insertBefore(item, index);\n      insertionLength += insertionResult.length;\n      return insertBefore(item, index) + item;\n    }\n\n    throw Error(\"insertion is expected to be either a string or a function\");\n  }).join(\"\\n\");\n  return {\n    modifiedText: modifiedText,\n    insertionLength: insertionLength\n  };\n}\n\nexports.insertBeforeEachLine = insertBeforeEachLine;\n\nvar makeList = function (state0, api, insertBefore) {\n  // Adjust the selection to encompass the whole word if the caret is inside one\n  var newSelectionRange = MarkdownUtil_1.selectWord({\n    text: state0.text,\n    selection: state0.selection\n  });\n  var state1 = api.setSelectionRange(newSelectionRange);\n  var breaksBeforeCount = MarkdownUtil_1.getBreaksNeededForEmptyLineBefore(state1.text, state1.selection.start);\n  var breaksBefore = Array(breaksBeforeCount + 1).join(\"\\n\");\n  var breaksAfterCount = MarkdownUtil_1.getBreaksNeededForEmptyLineAfter(state1.text, state1.selection.end);\n  var breaksAfter = Array(breaksAfterCount + 1).join(\"\\n\");\n  var modifiedText = insertBeforeEachLine(state1.selectedText, insertBefore);\n  api.replaceSelection(\"\" + breaksBefore + modifiedText.modifiedText + breaksAfter); // Specifically when the text has only one line, we can exclude the \"- \", for example, from the selection\n\n  var oneLinerOffset = state1.selectedText.indexOf(\"\\n\") === -1 ? modifiedText.insertionLength : 0;\n  var selectionStart = state1.selection.start + breaksBeforeCount + oneLinerOffset;\n  var selectionEnd = selectionStart + modifiedText.modifiedText.length - oneLinerOffset; // Adjust the selection to not contain the **\n\n  api.setSelectionRange({\n    start: selectionStart,\n    end: selectionEnd\n  });\n};\n\nexports.makeList = makeList;\nexports.unorderedListCommand = {\n  buttonProps: {\n    \"aria-label\": \"Add unordered list\"\n  },\n  execute: function (_a) {\n    var initialState = _a.initialState,\n        textApi = _a.textApi;\n    exports.makeList(initialState, textApi, \"- \");\n  }\n};\nexports.orderedListCommand = {\n  buttonProps: {\n    \"aria-label\": \"Add ordered list\"\n  },\n  execute: function (_a) {\n    var initialState = _a.initialState,\n        textApi = _a.textApi;\n    exports.makeList(initialState, textApi, function (item, index) {\n      return index + 1 + \". \";\n    });\n  }\n};\nexports.checkedListCommand = {\n  buttonProps: {\n    \"aria-label\": \"Add checked list\"\n  },\n  execute: function (_a) {\n    var initialState = _a.initialState,\n        textApi = _a.textApi;\n    exports.makeList(initialState, textApi, function (item, index) {\n      return \"- [ ] \";\n    });\n  }\n};","map":{"version":3,"sources":["/home/faha/local-repo/journey-to-react/2.notes-app/node_modules/react-mde/lib/js/commands/default-commands/listCommands.js"],"names":["Object","defineProperty","exports","value","checkedListCommand","orderedListCommand","unorderedListCommand","makeList","insertBeforeEachLine","MarkdownUtil_1","require","selectedText","insertBefore","lines","split","insertionLength","modifiedText","map","item","index","length","insertionResult","Error","join","state0","api","newSelectionRange","selectWord","text","selection","state1","setSelectionRange","breaksBeforeCount","getBreaksNeededForEmptyLineBefore","start","breaksBefore","Array","breaksAfterCount","getBreaksNeededForEmptyLineAfter","end","breaksAfter","replaceSelection","oneLinerOffset","indexOf","selectionStart","selectionEnd","buttonProps","execute","_a","initialState","textApi"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.checkedListCommand = exports.orderedListCommand = exports.unorderedListCommand = exports.makeList = exports.insertBeforeEachLine = void 0;\nvar MarkdownUtil_1 = require(\"../../util/MarkdownUtil\");\n/**\n * Inserts insertionString before each line\n */\nfunction insertBeforeEachLine(selectedText, insertBefore) {\n    var lines = selectedText.split(/\\n/);\n    var insertionLength = 0;\n    var modifiedText = lines\n        .map(function (item, index) {\n        if (typeof insertBefore === \"string\") {\n            insertionLength += insertBefore.length;\n            return insertBefore + item;\n        }\n        else if (typeof insertBefore === \"function\") {\n            var insertionResult = insertBefore(item, index);\n            insertionLength += insertionResult.length;\n            return insertBefore(item, index) + item;\n        }\n        throw Error(\"insertion is expected to be either a string or a function\");\n    })\n        .join(\"\\n\");\n    return { modifiedText: modifiedText, insertionLength: insertionLength };\n}\nexports.insertBeforeEachLine = insertBeforeEachLine;\nvar makeList = function (state0, api, insertBefore) {\n    // Adjust the selection to encompass the whole word if the caret is inside one\n    var newSelectionRange = MarkdownUtil_1.selectWord({\n        text: state0.text,\n        selection: state0.selection\n    });\n    var state1 = api.setSelectionRange(newSelectionRange);\n    var breaksBeforeCount = MarkdownUtil_1.getBreaksNeededForEmptyLineBefore(state1.text, state1.selection.start);\n    var breaksBefore = Array(breaksBeforeCount + 1).join(\"\\n\");\n    var breaksAfterCount = MarkdownUtil_1.getBreaksNeededForEmptyLineAfter(state1.text, state1.selection.end);\n    var breaksAfter = Array(breaksAfterCount + 1).join(\"\\n\");\n    var modifiedText = insertBeforeEachLine(state1.selectedText, insertBefore);\n    api.replaceSelection(\"\" + breaksBefore + modifiedText.modifiedText + breaksAfter);\n    // Specifically when the text has only one line, we can exclude the \"- \", for example, from the selection\n    var oneLinerOffset = state1.selectedText.indexOf(\"\\n\") === -1 ? modifiedText.insertionLength : 0;\n    var selectionStart = state1.selection.start + breaksBeforeCount + oneLinerOffset;\n    var selectionEnd = selectionStart + modifiedText.modifiedText.length - oneLinerOffset;\n    // Adjust the selection to not contain the **\n    api.setSelectionRange({\n        start: selectionStart,\n        end: selectionEnd\n    });\n};\nexports.makeList = makeList;\nexports.unorderedListCommand = {\n    buttonProps: { \"aria-label\": \"Add unordered list\" },\n    execute: function (_a) {\n        var initialState = _a.initialState, textApi = _a.textApi;\n        exports.makeList(initialState, textApi, \"- \");\n    }\n};\nexports.orderedListCommand = {\n    buttonProps: { \"aria-label\": \"Add ordered list\" },\n    execute: function (_a) {\n        var initialState = _a.initialState, textApi = _a.textApi;\n        exports.makeList(initialState, textApi, function (item, index) { return index + 1 + \". \"; });\n    }\n};\nexports.checkedListCommand = {\n    buttonProps: { \"aria-label\": \"Add checked list\" },\n    execute: function (_a) {\n        var initialState = _a.initialState, textApi = _a.textApi;\n        exports.makeList(initialState, textApi, function (item, index) { return \"- [ ] \"; });\n    }\n};\n"]},"metadata":{},"sourceType":"script"}